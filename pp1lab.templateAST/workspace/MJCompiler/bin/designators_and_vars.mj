program MJProgram

int b2, c;
const int b1 = 2;
const char c1 = 'a';
char c2;
bool bool_var;
int f;
const bool y = false;

class Parent{
int grand_parent_field;
}
class B extends Parent{
int parent_field;
int array[];
{
	int method1(int array[]){
	return 2;
	}
}
}
class C{
int c;
}

class A extends B{
  int bField;
  int cField[];
  A field;
 { 
  int method(int a) int b; {
    this.field.bField = b;
    return method1(array);
    
  }
 }
}

B object[];
A object1;
A object2[];
C test_object;


int bArray[];

{
    
    int function(int a, int b, int c[], B argument, B array[]){
    }
    int method(int a){
    }
	void main() B object[]; B test_object; {
		f = b1;
		bool_var = true;
		c2 = 'c';
		object = new A[50];
		f = (object2[0].cField[2] + 2);
		object = new B[5];
		object[1] = new A;
		object[1].parent_field = object1.method(2); 
		object[0] = object1;
		object[2] = null;
		object[1] = object2[2];
		object[object1.method(2) + object2[1].method(object[1].parent_field - object1.method(object2[2].parent_field * object1.cField[1] + b1))] = object1;
		object[object1.method(2) + object2[1].method(object[1].parent_field - object1.method(object2[2].parent_field * object1.cField[1] + b1))].parent_field = 1; 
		do{
		  break;
		}while(object[1] != object[2] && object[1].parent_field >= object[0].parent_field || object[0].parent_field < object[0].parent_field);
		
		object2[1].cField[1]++;
		read(object2[0].cField[0]);
		print(object[1].parent_field, 1);
		if(c || b1){
			switch(c * (object[2].parent_field % 2) + b1*3 + (b1 + (2*object[1].parent_field))){
				case 2: break; 
			}
		}
		object1.cField[0]--;
		function(f,1, bArray, object1, object2);
		object1.grand_parent_field = 2;
		object[0] = c > 0 && c < 255 || bool_var ? object[1] : null;
		test_object = object[0];
		return; 
	}	
}